Function New-OutputFolder {
<#

    .SYNOPSIS
    Function intended for preparing a folder name for output folders like reports or logs.

    .DESCRIPTION
    Function intended for preparing folder name for output folders like reports or logs based on prefix, middle name part, suffix, date, etc. with verification if provided path is writable

    Returned object contains properties
    - OutputFolderPath - to use it please check an examples - as a [System.IO.FolderInfo]
    - ExitCode
    - ExitCodeDescription

    Exit codes and descriptions
    0 = "Everything is fine :-)"
    1 = "Provided path <PATH> doesn't exist and can't be created
    2 = "Provided patch <PATH> doesn't exist and value for the parameter CreateOutputFolderDirectory is set to False"
    3 = "Provided patch <PATH> is not writable"
    4 = "The folder <PATH>\\<FOLDER_NAME> already exist  - can't be overwritten"
    5 = "The folder <PATH>\\<FOLDER_NAME> already exist  - can be overwritten"

    .PARAMETER OutputFolderDirectoryPath
    By default output folders are stored in subfolder "outputs" in current path

    .PARAMETER CreateOutputFolderDirectory
    Set tu TRUE if provided output folder directory should be created if is missed

    .PARAMETER OutputFolderNamePrefix
    Prefix used for creating output folders name

    .PARAMETER OutputFolderNameMidPart
    Part of the name which will be used in midle of output folder name

    .PARAMETER OutputFolderNameSuffixPart
    Part of the name which will be used at the end of output folder name

    .PARAMETER IncludeDateTimePartInOutputFolderName
    Set to TRUE if report folder name should contains part based on date and time - format yyyyMMdd-HHmm is used

    .PARAMETER DateTimePartInOutputFolderName
    Set to date and time which should be used in output folder name, by default current date and time is used
    
    .PARAMETER NamePartsSeparator
    A char used to separate parts in the name, by default "-" is used

    .PARAMETER BreakIfError
    Break function execution if parameters provided for output folder creation are not correct or destination folder path is not writables

    .EXAMPLE

    PS \> $PerServerReportFolderMessages = New-OutputFolder -OutputFolderDirectoryPath 'C:\USERS\Wojtek\' -OutputFolderNamePrefix 'Messages' `
                                                                    -OutputFolderNameMidPart 'COMPUTERNAME' `
                                                                    -IncludeDateTimePartInOutputFolderName:$true `
                                                                    -BreakIfError:$true

    PS \> $PerServerReportFolderMessages | Format-List

    OutputFolderPath                                           ExitCode ExitCodeDescription
    --------------                                           -------- -------------------
    C:\users\wojtek\Messages-COMPUTERNAME-20151021-0012-.txt        0 Everything is fine :-)

    .EXAMPLE

    PS \> $PerServerReportFolderMessages = New-OutputFolder -OutputFolderDirectoryPath 'C:\USERS\Wojtek\' -OutputFolderNamePrefix 'Messages' `
                                                                    -OutputFolderNameMidPart 'COMPUTERNAME' -IncludeDateTimePartInOutputFolderName:$true
                                                                    -OutputFolderNameExtension rxc -OutputFolderNameSuffix suffix `
                                                                    -BreakIfError:$true


    PS \> $PerServerReportFolderMessages.OutputFolderPath | select Name,Directory | Format-List

    Name      : Messages-COMPUTERNAME-20151022-235607-suffix.rxc
    Directory : C:\USERS\Wojtek

    PS \> ($PerServerReportFolderMessages.OutputFolderPath).gettype()

    IsPublic IsSerial Name                                     BaseType
    -------- -------- ----                                     --------
    True     True     FolderInfo                                 System.IO.FolderSystemInfo

    .OUTPUTS
    System.Object[]

    .LINK
    https://github.com/it-praktyk/New-OutputObject

    .LINK
    https://www.linkedin.com/in/sciesinskiwojciech

    .NOTES
    AUTHOR: Wojciech Sciesinski, wojciech[at]sciesinski[dot]net
    KEYWORDS: PowerShell, FolderSystem

    VERSIONS HISTORY
    - 0.1.0 - 2016-06-10 - Initial release, based on the New-OutputFolder v. 0.8.1
    - 0.2.0 - 2016-06-10 - The parameter for a folder prefix removed, Pester test added
    
    REMARKS
    - The warning generated by PSScriptAnalyzer "Function 'New-OutputFolder' has verb that could change system state. Therefore, the function has to support 'ShouldProcess'." is acceptable.

    TODO
    - replace long lines with parameters splattings in the examples
    - Trim provided parameters
    - Replace not standard chars ?
    - Check if all chars are allowed in the folder name e.g. ''%'  
    - Add support to incrementint suffix -like "000124"
    

    LICENSE
    Copyright (c) 2016 Wojciech Sciesinski
    This function is licensed under The MIT License (MIT)
    Full license text: https://opensource.org/licenses/MIT

    #>
    
    [cmdletbinding()]
    [OutputType([System.Object[]])]
    param (
        [parameter(Mandatory = $false)]
        [String]$OutputFolderDirectoryPath = ".\Outputs\",
        [parameter(Mandatory = $false)]
        [Bool]$CreateOutputFolderDirectory = $true,
        [parameter(Mandatory = $false)]
        [String]$OutputFolderNamePrefix = "Output-",
        [parameter(Mandatory = $false)]
        [String]$OutputFolderNameMidPart = $null,
        [parameter(Mandatory = $false)]
        [String]$OutputFolderNameSuffix = $null,
        [parameter(Mandatory = $false)]
        [Bool]$IncludeDateTimePartInOutputFolderName = $true,
        [parameter(Mandatory = $false)]
        [Nullable[DateTime]]$DateTimePartInOutputFolderName = $null,
        [parameter(Mandatory = $false)]
        [alias("Separator")]
        [String]$NamePartsSeparator="-",
        [parameter(Mandatory = $false)]
        [Bool]$BreakIfError = $true

    )

    #Declare variable

    [Int]$ExitCode = 0

    [String]$ExitCodeDescription = "Everything is fine :-)"

    $Result = New-Object -TypeName PSObject

    #Convert relative path to absolute path
    [String]$OutputFolderDirectoryPath = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($OutputFolderDirectoryPath)

    #Assign value to the variable $IncludeDateTimePartInOutputFolderName if is not initialized
    If ($IncludeDateTimePartInOutputFolderName -and $DateTimePartInOutputFolderName -eq $null) {

        [String]$DateTimePartInFolderNameString = $(Get-Date -format yyyyMMdd)

    }
    Else {

        [String]$DateTimePartInFolderNameString = $(Get-Date -Date $DateTimePartInOutputFolderName -format yyyyMMdd)

    }

    #Check if Output directory exist and try create if not
    If ($CreateOutputFolderDirectory -and !$((Get-Item -Path $OutputFolderDirectoryPath -ErrorAction SilentlyContinue) -is [system.io.directoryinfo])) {

        Try {

            $ErrorActionPreference = 'Stop'

            New-Item -Path $OutputFolderDirectoryPath -type Directory | Out-Null

        }
        Catch {

            [String]$MessageText = "Provided path {0} doesn't exist and can't be created" -f $OutputFolderDirectoryPath

            If ($BreakIfError) {

                Throw $MessageText

            }
            Else {

                Write-Error -Message $MessageText

                [Int]$ExitCode = 1

                [String]$ExitCodeDescription = $MessageText

            }

        }

    }
    ElseIf (!$((Get-Item -Path $OutputFolderDirectoryPath -ErrorAction SilentlyContinue) -is [system.io.directoryinfo])) {

        [String]$MessageText = "Provided patch {0} doesn't exist and value for the parameter CreateOutputFolderDirectory is set to False" -f $OutputFolderDirectoryPath

        If ($BreakIfError) {

            Throw $MessageText

        }
        Else {

            Write-Error -Message $MessageText

            [Int]$ExitCode = 2

            [String]$ExitCodeDescription = $MessageText

        }

    }

    #Try if Output directory is writable - temporary folder is stored
    Try {

        $ErrorActionPreference = 'Stop'

        [String]$TempFolderName = [System.IO.Path]::GetFileNameWithoutExtension() -replace '.*\\', ''

        [String]$TempFolderPath = "{0}{1}" -f $OutputFolderDirectoryPath, $TempFolderName
        
        New-Item -Path $TempFolderPath -type Directory | Out-Null
        
    }
    Catch {

        [String]$MessageText = "Provided patch {0} is not writable" -f $OutputFolderDirectoryPath

        If ($BreakIfError) {

            Throw $MessageText

        }
        Else {

            Write-Error -Message $MessageText

            [Int]$ExitCode = 3

            [String]$ExitCodeDescription = $MessageText

        }

    }

    Remove-Item -Path $TempFolderPath -ErrorAction SilentlyContinue | Out-Null

    #Constructing the folder name
    If (!($IncludeDateTimePartInOutputFolderName) -and !([String]::IsNullOrEmpty($OutputFolderNameMidPart)) ) {

        [String]$OutputFolderPathTemp1 = "{0}\{1}{3}{2}" -f $OutputFolderDirectoryPath, $OutputFolderNamePrefix, $OutputFolderNameMidPart, $NamePartsSeparator

    }
    Elseif (!($IncludeDateTimePartInOutputFolderName) -and [String]::IsNullOrEmpty($OutputFolderNameMidPart )) {

        [String]$OutputFolderPathTemp1 = "{0}\{1}" -f $OutputFolderDirectoryPath, $OutputFolderNamePrefix

    }
    ElseIf ($IncludeDateTimePartInOutputFolderName -and !([String]::IsNullOrEmpty($OutputFolderNameMidPart))) {

        [String]$OutputFolderPathTemp1 = "{0}\{1}{4}{2}{4}{3}" -f $OutputFolderDirectoryPath, $OutputFolderNamePrefix, $OutputFolderNameMidPart, $DateTimePartInFolderNameString, $NamePartsSeparator

    }
    Else {

        [String]$OutputFolderPathTemp1 = "{0}\{1}[3}{2}" -f $OutputFolderDirectoryPath, $OutputFolderNamePrefix, $DateTimePartInFolderNameString, $NamePartsSeparator

    }

    If ( [String]::IsNullOrEmpty($OutputFolderNameSuffix)) {

        [String]$OutputFolderPathTemp = "{0}" -f $OutputFolderPathTemp1

    }
    Else {

        [String]$OutputFolderPathTemp = "{0}{2}{1}" -f $OutputFolderTemp1, $OutputFolderNameSuffix, $NamePartsSeparator

    }

    #Replacing doubled chars \\ , -- , .. - except if \\ is on begining - means that path is UNC share
    [System.IO.FolderInfo]$OutputFolderPath = "{0}{1}" -f $OutputFolderPathTemp.substring(0, 2), (($OutputFolderPathTemp.substring(2, $OutputFolderPathTemp.length - 2).replace("\\", '\')).replace("--", "-")).replace("..", ".")

    If ($ErrorIfOutputFolderExist -and (Test-Path -Path $OutputFolderPath -PathType Container)) {
        
        
        #Dialog for decision if Force was not set or Overwrite All not selected previously
        [String]$Title = "Overwrite Folder"
        
        [String]$MessageText = "The folder {0} already exist" -f $OutputFolderPath
                
        $yes = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", `
                          "The folder already exists. Overwrite the existing folder."
        
        #$yesall = New-Object System.Management.Automation.Host.ChoiceDescription "&All", `
        #                     "Overwrite the all existing folders."
        
        $no = New-Object System.Management.Automation.Host.ChoiceDescription "&No", `
                         "Retain the existing folder."
        
        #$noall = New-Object System.Management.Automation.Host.ChoiceDescription "N&o for All", `
        #                   "Retain the all existing folders."
        
        $cancel = New-Object System.Management.Automation.Host.ChoiceDescription "&Cancel", `
                             "Cancel."
        
        $options = [System.Management.Automation.Host.ChoiceDescription[]]($yes, $no, $cancel)
        
        $Answer = $host.ui.PromptForChoice($Title, $MessageText, $Options, 0)
        
        switch ($Answer) {
            
            0 {
                                
                [Int]$ExitCode = 4
                
                [String]$ExitCodeDescription = $MessageText
                
            }
            
            1 {
                
                [Int]$ExitCode = 4
                
                [String]$ExitCodeDescription = $MessageText
                
            }
            
            2 {
                
               Throw $MessageText 
                
            }
            
        }
 
    }

    $Result | Add-Member -MemberType NoteProperty -Name OutputFolderPath -Value $OutputFolderPath

    $Result | Add-Member -MemberType NoteProperty -Name ExitCode -Value $ExitCode

    $Result | Add-Member -MemberType NoteProperty -Name ExitCodeDescription -Value $ExitCodeDescription

    Return $Result

}
